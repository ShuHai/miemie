(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.miemie = factory());
}(this, (function () { 'use strict';

var ArrayMethod = function ArrayMethod () {};

ArrayMethod.prototype.hello = function hello (message) {
    var a = message || 'hello world';
    console.log(a);
};

// 数组去重
ArrayMethod.prototype.unique = function unique (arr) {
    // let result = []
    // arr.map(item => {
    //   result.indexOf(item) === -1 && result.push(item)
    // })
    // return result

    var _obj = {};
    arr.forEach(function (x) {
        _obj[x] = '';
    });
    return Object.getOwnPropertyNames(_obj)
};

// 判断是否是数组
ArrayMethod.prototype.isArray = function isArray (object) {
    return Object.prototype.toString.call(object) === '[object Array]'
};

// 数组求交集
ArrayMethod.prototype.intersection = function intersection (arr1, arr2) {
    var setArr1 = new Set(arr1);
    var setArr2 = new Set(arr2);
    var result = new Set([].concat( setArr1 ).filter(function (x) {
        return setArr2.has(x)
    }));
    return Array.from(result)
};

// 数组求并集
ArrayMethod.prototype.union = function union (arr1, arr2) {
    var setArr1 = new Set(arr1);
    var setArr2 = new Set(arr2);
    return Array.from(new Set(setArr1.concat( setArr2)))
};

// 数组求差集
ArrayMethod.prototype.difference = function difference (arr1, arr2) {
    var setArr1 = new Set(arr1);
    var setArr2 = new Set(arr2);
    var result = new Set([].concat( setArr1 ).filter(function (x) {
        return !setArr2.has(x)
    }));
    return Array.from(result)
};

// 数组前n个元素去掉
ArrayMethod.prototype.drop = function drop (arr, n) {
    if (!n && arr) {
        arr.shift();
        return arr
    } else {
        for (var i = 0; i < n; i++) {
            arr.shift();
        }
        return arr
    }

};

var NumberMethod = function NumberMethod () {};

NumberMethod.prototype.isNumber = function isNumber (num) {
  return !isNaN(num)
};
// 求和
NumberMethod.prototype.sum = function sum () {
    var this$1 = this;

  var sum = 0;
  var args = Array.prototype.slice.call(arguments);
  args.map(function (item) {
    sum += this$1.isNumber(item) ? item : 0;
  });
  return sum
};

var ObjectMethod = function ObjectMethod () {};

ObjectMethod.prototype.deepClone = function deepClone (obj) {
    var this$1 = this;

  var newObj = obj.constructor === Array ? [] : {};
  if (typeof obj !== 'object') {
    return
  } else {
    for (var i in obj) {
      newObj[i] = typeof obj[i] === 'object' ? this$1.deepClone(obj[i]) : obj[i];
    }
  }
  return newObj
};

// 合并对象
ObjectMethod.prototype.assign = function assign () {
  var args = Array.prototype.slice.call(arguments);
  var obj = {};
  console.log(args);
  if (args.length) {
    args.forEach(function (item) {
      obj = Object.assign(obj, item);
    });
  }
  return obj
};

var Mie = function Mie () {
  this.array = new ArrayMethod();
  this.number = new NumberMethod();
  this.object = new ObjectMethod();
};

var miemie = new Mie();

return miemie;

})));
